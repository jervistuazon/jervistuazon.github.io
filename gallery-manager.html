<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gallery Manager V2</title>
    <!-- SortableJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <!-- InteractJS for Resizing -->
    <script src="https://cdn.jsdelivr.net/npm/interactjs/dist/interact.min.js"></script>
    <script src="gallery-data.js"></script>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --text-primary: #f5f5f5;
            --grid-gap: 20px;
            --cell-size: 200px;
            /* Base unit size for 1x1 */
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Segoe UI', sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        header {
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
        }

        select,
        button {
            padding: 10px 15px;
            background: #222;
            color: #fff;
            border: 1px solid #444;
            border-radius: 4px;
            cursor: pointer;
        }

        button.primary {
            background: #4a90e2;
            border-color: #4a90e2;
        }

        button:hover {
            opacity: 0.9;
        }

        .workspace {
            display: flex;
            gap: 20px;
            flex: 1;
            overflow: hidden;
        }

        .editor {
            flex: 1;
            overflow-y: auto;
            border: 1px solid #333;
            background: #111;
            padding: 40px;
            position: relative;
        }

        /* 
           We use CSS Grid for the display, but for resizing drag-and-drop, 
           InteractJS works best with absolute or transformed elements.
           HOWEVER, mixing Sortable (reorder) and Interact (resize) is tricky.
           Strategy:
           - Use CSS Grid for layout.
           - Resize simply toggles classes (span-X-X).
           - The "Handle" is just a UI trigger. Dragging it updates the class.
        */

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            /* 3 Columns as per site */
            gap: var(--grid-gap);
            max-width: 1200px;
            margin: 0 auto;
            padding-bottom: 100px;
        }

        .grid-item {
            background: #222;
            border: 1px solid #444;
            position: relative;
            /* Prevent interaction on children to allow drag */
            user-select: none;
            transition: all 0.2s;
        }

        /* Span Classes (Visual) */
        .span-1-1 {
            grid-column: span 1;
            grid-row: span 1;
            aspect-ratio: 16/9;
        }

        .span-2-1 {
            grid-column: span 2;
            grid-row: span 1;
            aspect-ratio: 32/9;
        }

        .span-1-2 {
            grid-column: span 1;
            grid-row: span 2;
            aspect-ratio: 8/9;
        }

        .span-2-2 {
            grid-column: span 2;
            grid-row: span 2;
            aspect-ratio: 16/9;
            /* Big box */
        }

        .span-3-1 {
            grid-column: span 3;
            grid-row: span 1;
            aspect-ratio: 48/9;
        }

        .span-3-2 {
            grid-column: span 3;
            grid-row: span 2;
            aspect-ratio: 48/18;
        }

        .grid-item img,
        .grid-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            opacity: 0.8;
        }

        /* Resize Handle */
        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, transparent 50%, #4a90e2 50%);
            cursor: nwse-resize;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .grid-item:hover .resize-handle {
            opacity: 1;
        }

        .grid-item:hover {
            border-color: #4a90e2;
            z-index: 10;
        }

        .info-badge {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.8);
            font-size: 10px;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .output-panel {
            width: 300px;
            background: #151515;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        textarea {
            flex: 1;
            background: black;
            color: #0f0;
            border: 1px solid #333;
            resize: none;
            font-family: monospace;
            padding: 10px;
            font-size: 11px;
        }

        /* Limit Line */
        .limit-line {
            grid-column: 1 / -1;
            height: 2px;
            background: red;
            margin: 10px 0;
            position: relative;
            display: none;
            /* Only show in main gallery */
        }

        .limit-line::after {
            content: "MAX 3 ROWS APPROX";
            position: absolute;
            right: 0;
            top: -20px;
            color: red;
            font-weight: bold;
            font-size: 12px;
        }
    </style>
</head>

<body>

    <header>
        <h2>Gallery Manager V2</h2>
        <select id="modeSelect">
            <option value="MAIN">Main Gallery (Home Page)</option>
            <option value="INDIVIDUAL">Individual Projects...</option>
        </select>
        <select id="folderSelect" style="display:none;"></select>
        <button id="generateBtn" class="primary">Generate Config</button>
    </header>

    <div class="workspace">
        <div class="editor">
            <div id="grid" class="grid-container">
                <!-- Items -->
            </div>
        </div>

        <div class="output-panel">
            <h3>Config Output</h3>
            <p style="font-size:12px; color:#888;">Paste this into `gallery-data.js`</p>
            <textarea id="output" readonly></textarea>
            <button onclick="copyOut()">Copy</button>
        </div>
    </div>

    <script>
        let currentMode = 'MAIN';
        let currentItems = []; // Contains objects with data
        const grid = document.getElementById('grid');
        const modeSelect = document.getElementById('modeSelect');
        const folderSelect = document.getElementById('folderSelect');

        // === Initialization ===
        document.addEventListener('DOMContentLoaded', () => {
            if (!window.galleryData) return alert("No Gallery Data");

            populateFolders();
            loadMainGallery(); // Default
        });

        modeSelect.addEventListener('change', (e) => {
            currentMode = e.target.value;
            if (currentMode === 'MAIN') {
                folderSelect.style.display = 'none';
                loadMainGallery();
            } else {
                folderSelect.style.display = 'inline-block';
                if (folderSelect.value) loadFolder(folderSelect.value);
                else folderSelect.selectedIndex = 0;
            }
        });

        folderSelect.addEventListener('change', (e) => loadFolder(e.target.value));

        function populateFolders() {
            for (const key in galleryData) {
                if (key === 'HERO SHOT') continue;
                const op = document.createElement('option');
                op.value = key;
                op.textContent = key;
                folderSelect.appendChild(op);
            }
        }

        // === Data Loading ===

        function loadMainGallery() {
            currentItems = [];

            // 1. Flatten Data
            for (const [key, files] of Object.entries(galleryData)) {
                if (key === 'HERO SHOT') continue;

                const isExploded = (key === 'Animation' || key === 'Interactive Presentation');

                if (isExploded) {
                    // Add every item
                    files.forEach(f => {
                        const src = (typeof f === 'object') ? f.src : f;
                        const span = (typeof f === 'object') ? f.span : 'span-1-1';
                        currentItems.push({
                            type: 'item',
                            src: src,
                            folder: key,
                            span: span,
                            name: src
                        });
                    });
                } else {
                    // Add Folder as single item
                    const thumbnail = files[0];
                    const src = (typeof thumbnail === 'object') ? thumbnail.src : thumbnail;
                    // Folder itself might have stored span preference in future, 
                    // but for now we store it on the thumbnail object? 
                    // Or we need a separate "layout" config.
                    // Current V1 implementation used thumbnail.span to control folder size.
                    const span = (typeof thumbnail === 'object') ? thumbnail.span : 'span-1-1';

                    currentItems.push({
                        type: 'folder',
                        folder: key,
                        thumbnail: src, // We keep ref to first image
                        span: span,
                        name: key
                    });
                }
            }

            render();
        }

        function loadFolder(folderName) {
            currentItems = [];
            const files = galleryData[folderName];

            files.forEach(f => {
                const src = (typeof f === 'object') ? f.src : f;
                const span = (typeof f === 'object') ? f.span : 'span-1-1';
                currentItems.push({
                    type: 'item',
                    src: src,
                    folder: folderName,
                    span: span,
                    name: src
                });
            });

            render();
        }

        // === Rendering ===

        function render() {
            grid.innerHTML = '';

            currentItems.forEach((item, index) => {
                const el = document.createElement('div');
                el.className = `grid-item ${item.span}`;
                el.dataset.index = index;

                // Media
                let path = '';
                if (item.type === 'folder') {
                    path = `assets/${item.folder}/${item.thumbnail}`;
                } else {
                    path = `assets/${item.folder}/${item.src}`;
                }

                const encoded = path.split('/').map(encodeURIComponent).join('/');

                // Check video
                if (path.match(/\.(mp4|mov|webm)$/i)) {
                    const v = document.createElement('video');
                    v.src = encoded;
                    v.muted = true;
                    el.appendChild(v);
                } else {
                    const i = document.createElement('img');
                    i.src = encoded;
                    el.appendChild(i);
                }

                // Info Badge
                const badge = document.createElement('div');
                badge.className = 'info-badge';
                badge.textContent = item.name;
                el.appendChild(badge);

                // Resize Handle
                const handle = document.createElement('div');
                handle.className = 'resize-handle';

                // InteractJS for resizing logic
                // Actually, for a grid, "dragging a corner" usually implies 
                // snapping to the next grid cell.
                // We can emulate this by cycling sizes on drag, or tracking dx/dy.
                // Simple approach: Click handle to cycle? User asked to "drag".
                // Let's implement real drag detect.

                initResizeHandle(handle, index);

                el.appendChild(handle);
                grid.appendChild(el);
            });

            // Sortable
            if (this.sortable) this.sortable.destroy();
            this.sortable = new Sortable(grid, {
                animation: 150,
                onEnd: () => {
                    // Re-read DOM to update array order
                    const newItems = [];
                    const els = grid.querySelectorAll('.grid-item');
                    els.forEach(el => {
                        const idx = parseInt(el.dataset.index);
                        newItems.push(currentItems[idx]);
                    });
                    currentItems = newItems;
                    // Update indices
                    render();
                }
            });
        }

        // === Resize Logic ===

        function initResizeHandle(handle, index) {
            interact(handle).draggable({
                onmove: (event) => {
                    // We don't verify move, just detect "drag amount" to snap?
                    // Visual feedback is hard without complex ghosting.
                    // Alternative: Just use the delta to switch class.
                },
                onend: (event) => {
                    // Simple logic:
                    // If Drag X > 50 -> Increase Width
                    // If Drag Y > 50 -> Increase Height
                    // If Drag X < -50 -> Decrease Width
                    // etc.

                    const dx = event.pageX - event.x0;
                    const dy = event.pageY - event.y0;
                    const threshold = 30; // pixels

                    const item = currentItems[index];
                    let w = getWidth(item.span);
                    let h = getHeight(item.span);

                    if (dx > threshold && w < 3) w++; // Max 3 cols
                    if (dx < -threshold && w > 1) w--;

                    if (dy > threshold && h < 2) h++; // Max 2 rows
                    if (dy < -threshold && h > 1) h--;

                    item.span = getClass(w, h);
                    render();
                }
            });
        }

        function getWidth(span) {
            if (span.includes('span-3')) return 3;
            if (span.includes('span-2')) return 2;
            return 1;
        }

        function getHeight(span) {
            // e.g. span-2-2 -> height 2
            // span-1-2 -> height 2
            // The last number is typically row span in my class naming or implied?
            // Classes: span-1-1, span-2-1, span-1-2, span-2-2
            const parts = span.split('-');
            if (parts.length === 3) return parseInt(parts[2]);
            return 1;
        }

        function getClass(w, h) {
            return `span-${w}-${h}`;
        }

        // === Generation ===

        document.getElementById('generateBtn').addEventListener('click', () => {
            let outputStr = '';

            if (currentMode === 'MAIN') {
                // Generate window.galleryLayout
                outputStr += `// Place this usually at the end of gallery-data.js\n`;
                outputStr += `window.galleryLayout = [\n`;
                currentItems.forEach(item => {
                    // We need to store enough info to reconstruct the view
                    // For direct items: { type: 'item', folder: '...', src: '...', span: '...' }
                    // For folders: { type: 'folder', folder: '...', span: '...' }

                    if (item.type === 'folder') {
                        outputStr += `    { type: 'folder', folder: "${item.folder}", span: "${item.span}" },\n`;
                    } else {
                        outputStr += `    { type: 'item', folder: "${item.folder}", src: "${item.src}", span: "${item.span}" },\n`;
                    }
                });
                outputStr += `];`;
            } else {
                // Generate normal folder array
                const fName = document.getElementById('folderSelect').value;
                outputStr += `"${fName}": [\n`;
                currentItems.forEach(item => {
                    outputStr += `    { src: "${item.src}", span: "${item.span}" },\n`;
                });
                outputStr += `]`;
            }

            document.getElementById('output').value = outputStr;
        });

        function copyOut() {
            document.getElementById('output').select();
            document.execCommand('copy');
            alert("Copied!");
        }

    </script>
</body>

</html>